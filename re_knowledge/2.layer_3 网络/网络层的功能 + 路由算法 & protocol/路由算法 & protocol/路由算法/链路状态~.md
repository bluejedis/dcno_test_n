<div style="float: left; width: 64%; padding: 1%;">

#### 链路状态Link state 路由算法(D)

<ul>

- 链路状态是指本路由器都和哪些路由器相邻，以及相应链路的代价

##### 基本任务

<ul>

- 要求: 每个**结点**都具有**全网 拓扑结构图**（this拓扑结构图在全网范围内是一致的）
- 执行**两项任务**：
  - 主动测试所有**相邻结点**的**状态**
  - **定期**地将**链路状态**传播 → **所有其他结点**

</ul>

##### 算法工作过程

<ul>

- 每个结点all
  - 知道全网共有多少个结点、哪些结点是相连的、其代价是多少etc ← other NODEs' info
  - can use Dijkstra**最短路径算法**
    - 计算出到达其他结点的最短路径
- 结点每收到一个链路状态报文
  - use it to更新自己的网络状态"视野图"
  - once链路状态发生变化
    - use Dijkstra算法重新计算到达所有其他结点的最短路径

</ul>

##### 算法优点

<ul>

>独立
- 每个结点都使用同样的链路状态数据**独立**地**计算**路径，而**不依赖中间**结点的计算
- 链路状态报文**不加改变地传播**，thus采用该算法**易于查找敌障**
- 当一个结点**从所有其他结点**接收到报文时，它就在本地立即计算出正确的路径，**保证一步汇聚**
- 因为链路状态报文仅运载**来自单个结点**关于直接链路的信息，其**大小与**网络中的**结点数目无关**
- comparison： 链路状态算法比距离-向量算法有**更好的**规模**可伸展性**

</ul>

##### 两种路由算法的比较

<ul>

- 距离-向量算法
  - 每个结点**仅**与它的**直接邻居**交谈
  - 向它的邻居发送自己的路由表
  - 其大小**取决于**网络中的**结点数目**，代价较大
- 链路状态算法
  - 每个结点通过广播的方式与**所有其他**结点交谈
  - 只告诉它们与它**直接相连**的链路的费用
  - 典型的链路状态路由算法是OSPF算法

</ul>

</ul>

</ul>


</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
