<div style="float: left; width: 64%; padding: 1%;">

### 路由信息协议（RIP）

<ul>

> 一种分布式的基于距离向量的路由选择协议

#### RIP的基本规定

<ul>

- 应用范围
  - is内部网关协议IGP中最先得到广泛apply的protocol
- 基本要求
  - 网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录
  - RIP使用跳数（HopCount）来衡量到达目的网络的距离
    - 从一路由器到直接连接的网络的距离定义为1
    - 每经过一个路由器，距离就加1
  - RIP认为好的路由就是通过的路由器数目少

> **pro：RIP中跳数为16的含义（2010）**

- 跳数限制
  - RIP允许一条路径最多只能包含15个路由器
    - 距离等于16时表示网络不可达
    - RIP只适用于小型互联网
    - 限制跳数目的是防止分组在环路上循环
- 路由表结构
  - 每个路由表项都有三个关键字段：<目的网络 $N$ ，距离 $d$ ，下一跳路由器地址 $\chi>$

</ul>

#### RIP的特点

<ul>

##### 信息交换机制

<ul>

- 交换对象
  - 仅和直接相邻的路由器交换信息
- 交换内容
  - 交换的信息是本路由器所知道的全部信息，即自己的路由表
- 交换时机
  - 按固定的时间间隔（如30秒）交换
  - 网络拓扑变化时及时通告

</ul>

##### 路由器工作过程

<ul>

- 初始阶段
  - 只知道自己到直接相连的几个网络的距离为1
- 更新阶段
  - 每个路由器仅和相邻路由器周期性地交换并更新路由信息
- 收敛阶段
  - 所有路由器最终知道到达本自治系统内任何网络的最短距离和下一跳路由器地址

> **pro：封装RIP报文所采用的协议（2017）**

</ul>

##### 协议特性

<ul>

- 传输层协议
  - RIP是应用层协议，使用UDP传送数据（端口520）
- 路径选择
  - RIP选择的路径不一定是时间最短的
  - 一定是具有最少的路由跳数

</ul>

</ul>

#### RIP的距离向量算法

<ul>

- 对每个相邻路由器发送来的RIP报文，执行如下步骤：

##### 步骤1：报文修改

<ul>

- 对地址为 $X$ 的相邻路由器发来的RIP报文，先修改此报文中的所有项目：
  - 把"下一跳"字段中的地址都改为 $X,$ 
  - 并把所有"距离"字段的值加1

</ul>

##### 步骤2：项目处理

<ul>

- 对修改后的RIP报文中的每个项目，执行如下步骤：
  - IF（若原来的路由表中没有目的网络 $N$) 则把该项目添加到路由表中（表明这是新的目的网络）
  - ELSEIF（若原来的路由表中有目的网络 $N$ ，且下一跳路由器的地址是 $X)$ 用收到的项目替换原路由表中的项目（因为要以更新的消息为准）
  - ELSEIF（若原来的路由表中有目的网络 $N$ ，且下一跳路由器的地址不是 $X)$ 若收到的项目中的距离 $d$ 小于路由表中的距离，则进行更新
  - ELSE什么也不做

</ul>

##### 步骤3：超时处理

<ul>

- 若180秒（RIP默认超时时间）还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离设置为16（距离为16表示不可达）

</ul>

##### 步骤4：返回

<ul>

- 举例说明RIP路由条目的更新过程：
  - 已知路由器R6和R4互为相邻路由器，表4.4(a)所示为R6的路由表，现在收到相邻路由器R4发来的路由更新信息，如表4.4(b)所示

表4.4(a）R6的路由表 ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/889f89c59d634d95c1bd9984787004bbb1abfc4ccc76b076c5aebc5983ca6261.jpg)

表4.4(b）R4发来的路由表 ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91cd1866cfc529d657f0a9580a36d851d3fc8364d3a2201b39819805333824a4.jpg)

- 更新R6的路由表过程：
  - 先把 $\mathrm{R_{4}}$ 发来的路由表［表4.4(b)]中各项的距离都加1，并把下一跳路由器都改为R4，得到表4.5(a)
  - 将这个表的每行与R6的路由表[表4.4(a)］进行比较：
    - 第一行的Netl在表4.4(a)中没有，thus要把这一行添加到表4.4(a)中
    - 第二行的Net2在表4.4(a)中有，且下一跳路由器也是R4，thus要更新（距离增大了）
    - 第三行的Net3在表4.4(a)中有，但下一跳路由器不同。于是需要比较距离。新的路由信息的距离是2，小于原表中的4，thus要更新
  - 这样，得出更新后的R6的路由表如表4.5(b)所示

表4.5(a)修改R4发来的路由表 ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a97c4d76eb3895ef462128c5897814b8e3366a96be378450b6fc83b80323f2fd.jpg)

表4.5(b)R6更新后的路由表 ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91b094f046fb1e1478116d0079f503cecbaa272a878d4bac0f8118446d285adb.jpg)

</ul>

#### RIP的优缺点

<ul>

##### RIP的优点：

<ul>

- 实现简单、开销小、收敛过程较快
- 若一个路由器发现了更短的路由，则这种更新信息就传播得很快，在较短时间内便可被传至所有路由器，俗称"好消息传播得快"

</ul>

##### RIP的缺点：

<ul>

- RIP限制了网络的规模，它能使用的最大距离为15（16表示不可达）
- 路由器之间交换的是路由器中的完整路由表，thus网络规模越大，开销也越大
- 当网络出现故障时，路由器之间需反复多次交换信息才能完成收敛，要经过较长时间才能将故障消息传送到所有路由器（即慢收敛现象），俗称"坏消息传播得慢"

</ul>

##### RIP"好消息传播得快，坏消息传播得慢"的特点举例

<ul>

- 假设图4.16中的路由器都采用RIP交换路由信息，初始时R1到网络 $N$ 的距离为4，且R1和R2均已收敛

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fcb2f30da895050fcf0b8687df1e357c43fd6cb3ad48015e8494ffb22c268878.jpg)
图4.16RIP举例：链路开销改变

###### 好消息传播快的情况：

<ul>

- 在图4.16(a)中：
  - 某时刻R1的某个端口检测到"到 $N$ 更短的链路"（距离由4变为1）
  - R1计算其到 $N$ 的最新距离 = $\min\{1, 1+R2到N的距离\} = \min\{1, 1+5\} = 1$，并通知邻居
  - R2收到后，更新其到 $N$ 的距离为2，并通知邻居
  - R1收到后，R1到 $N$ 的最短距离未变，不再发送通知，算法进入静止状态
- 可见，R2到 $N$ 的距离减少的好消息通过RIP得到了迅速传播

> **pro：RIP"坏消息传播得慢"的分析（2016）**

</ul>

###### 坏消息传播慢的情况：

<ul>

- 在图4.16（b)中：
  - 某时刻R1的某个端口检测到" $^{\circ}N$ 不可达"（即距离变为16）
  - R1计算其到 $N$ 的最新距离 = $\min\{16, 1+R2到N的距离\} = \min\{16, 1+5\} = 6$ 
  - 从网络全局的视角可以看出，经过R2的这个新距离显然是错误的
  - R1算出到 $N$ 的最新距离后，通知邻居
  - R2收到后，更新其到 $N$ 的距离为7,通知邻居
  - R1收到后，计算其到 $N$ 的距离= $\min\{16, 1+R2到N的距离\} = \min\{16, 1+7\} = 8$，继续通知邻居
  - 如此循环，直到R2最终算出它经由R1到达 $N$ 的距离为16为止
- 可见，RIP关于链路故障或距离增加的坏消息传播得很慢

</ul>

</ul>

</ul>

</ul>

</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
