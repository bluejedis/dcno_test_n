<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，我们来到了第五章《传输层》！这一章是整个协议栈的**中枢**，直接为应用层服务，重要性不言而喻。**TCP协议是本章的绝对核心**，也是整个计网课程的**灵魂**所在。它的连接管理（三次握手、四次挥手）、可靠传输、流量控制和拥塞控制机制，是每年考研大题的**常客和主角**。

这一章必须做到滴水不漏。跟上我的思路，我们用最精炼的方式，彻底征服TCP/UDP！

---

### **第5章 传输层**

**本章定位**：如果说网络层是“跨国物流”，负责把包裹从**主机A**送到**主机B**的大门口，那传输层就是**“前台/收发室”**，负责把包裹从主机B的大门口，精准地送到**某个具体的部门/人（进程）**手中。它实现了**端到端（进程到进程）**的逻辑通信。

### **5.1 传输层提供的服务**

#### **5.1.1-5.1.2 传输层功能、寻址与端口**

* **核心考点**:
    * 传输层的核心功能：**进程到进程**的通信、**复用/分用**。
    * 端口号的作用，套接字（Socket）的定义。
* **形象记忆**:
    * **IP地址 vs 端口号**:
        * `IP地址`：一栋大楼的**街道地址**（定位到主机）。
        * `端口号`：大楼里每个房间的**门牌号**（定位到进程）。
    * **复用与分用**:
        * **复用 (发送方)**: 大楼里的很多人（多个进程）都可以把信件（数据）扔进同一个邮筒（传输层），由邮局统一寄出。
        * **分用 (接收方)**: 收发室（传输层）收到一大堆信件，根据信封上的门牌号（端口号），准确地分发给每个房间的人（进程）。
    * **套接字 (Socket)**:
        * **定义**: `Socket = (IP地址 : 端口号)`。
        * **作用**: 唯一确定了全网中的一个**通信端点**。就像“某市某街道100号大楼的808房间”，地址非常精确。

#### **5.1.3 无连接服务与面向连接服务**

* **核心考点**: UDP和TCP的核心区别。
* **形象记忆**:
    * **UDP (用户数据报协议)** - **无连接服务**:
        * **比喻**: 寄**平信**。
        * **特点**: 简单、快、开销小。不用先打电话确认对方在不在家。直接把信扔邮筒里就完事了。信可能会丢，也可能先发的后到，它都不管。**不可靠**。
        * **适用**: 实时性要求高、能容忍少量丢包的场景（如视频直播、语音通话、DNS查询）。
    * **TCP (传输控制协议)** - **面向连接服务**:
        * **比喻**: 打**电话**。
        * **特点**: 必须先“喂，听得到吗？”（建立连接），然后才能开始有序、可靠地对话，最后还要“再见”（释放连接）。开销大，但**可靠**。
        * **适用**: 可靠性要求高的场景（如文件传输FTP、网页浏览HTTP）。

---

### **5.2 UDP协议**

#### **5.2.1-5.2.2 UDP数据报与检验**

* **核心考点**:
    * UDP的特点总结。
    * UDP首部格式（非常简单，只需记忆）。
    * UDP检验和的计算范围（包含伪首部）。
* **形象记忆**:
    * **UDP首部 (8字节)**:
        * `[源端口(2B)] [目的端口(2B)] [长度(2B)] [检验和(2B)]`
        * **记忆**: 一个极简的信封，只写了“**你的门牌号**”、“**我的门牌号**”，标了一下信有多重，再盖个“**检验邮戳**”。
    * **UDP检验和**:
        * **特点**: 不仅检查UDP报文（首部+数据），还检查一个临时的“**伪首部**”。
        * **伪首部**: 包含了**源IP地址、目的IP地址、协议号**等信息。
        * **目的**: 防止IP包送错地方。就像邮递员不仅要确认信封没破，还要再次确认信封上的地址是不是真的送到了这栋楼，防止张冠李戴。

---

### **5.3 TCP协议**

这是 **【本章的绝对核心，每年必考的“巨无霸”】**。

#### **5.3.1-5.3.2 TCP协议特点与报文段**

* **核心考点**: TCP是`面向连接`、`可靠`、`全双工`的`字节流`服务。TCP报文段首部字段的含义，特别是**序号、确认号、6个控制位、窗口大小**。
* **形象记忆 (TCP首部)**:
    * **序号 (seq)**: 我这次发的数据，是从我整个文件字节流的**第几个字节开始**的。
    * **确认号 (ack)**: 我已经收到了你那边到**第`ack-1`个字节**的所有数据了，你**下次**请从**第`ack`个字节**开始发。
    * **6个控制位 (标志位)**: 就像打电话时的“暗语”。
        * `SYN`: “喂，我想跟你**建立连接**”。
        * `ACK`: “我**收到**了/同意”。
        * `FIN`: “我说完了，想**挂电话**了”。
        * `RST`: “出错了，**强制挂断**！”
        * `PSH`: “别攒着了，赶快把数据**推送**给应用！”
        * `URG`: “十万火急，这份是**紧急**数据！”
    * **窗口大小**: 我家（接收缓存）现在还能装下多少字节的数据，你看着发。

#### **5.3.3 TCP连接管理**

这是 **【面试、笔试的明星考点，必须倒背如流】**。

* **【模板】三次握手 (建立连接)**
    * **第1次**: **客户端 -> 服务器**: `SYN=1, seq=x`
        * **人话**: “服务器你好，我想和你建立连接，我的初始序列号是x。”
    * **第2次**: **服务器 -> 客户端**: `SYN=1, ACK=1, seq=y, ack=x+1`
        * **人话**: “客户端你好，我同意连接。我的初始序列号是y，我确认收到了你的x号报文，希望你下次从x+1号开始发。”
    * **第3次**: **客户端 -> 服务器**: `ACK=1, seq=x+1, ack=y+1`
        * **人话**: “服务器我收到了你的确认。现在我从x+1号开始发，并且我确认收到了你的y号报文，希望你下次从y+1号开始发。”
    * **为何要三次?**: 主要防止已失效的连接请求报文突然又传到服务器，导致服务器错误地开辟资源。

* **【模板】四次挥手 (释放连接)**
    * **第1次**: **客户端 -> 服务器**: `FIN=1, seq=u`
        * **人话**: “服务器，我这边没数据要发了，请求关闭（我到你这边）的通道。” (进入FIN_WAIT_1)
    * **第2次**: **服务器 -> 客户端**: `ACK=1, ack=u+1`
        * **人话**: “好的，收到了你的关闭请求。但我可能还有数据没发完，你等我一下。” (服务器进入CLOSE_WAIT，客户端进入FIN_WAIT_2，此时为**半关闭**状态)
    * **第3次**: **服务器 -> 客户端**: `FIN=1, seq=w`
        * **人话**: “客户端，我这边也发完数据了，请求关闭（我到你这边）的通道。” (进入LAST_ACK)
    * **第4次**: **客户端 -> 服务器**: `ACK=1, ack=w+1`
        * **人话**: “好的，收到了你的关闭请求，再见。” (进入**TIME_WAIT**，等待2MSL后关闭)
    * **为何要四次?**: 因为TCP是全双工的，一方关闭发送通道后，另一方可能还有数据要发送，所以FIN和ACK不能捆绑在一起，需要分开发送。
    * **为何要TIME_WAIT?**: 确保最后一次ACK能成功被对方接收。如果最后的ACK丢失，服务器会重传FIN，客户端还能响应。

#### **5.3.4-5.3.6 TCP可靠传输、流量控制、拥塞控制**

这是 **【TCP的精髓，综合大题的常客】**。

* **核心考点**:
    * 可靠传输的实现方式：`序号`、`确认`、`重传`（超时重传、快速重传）。
    * 流量控制：利用**滑动窗口**和接收方通告的**接收窗口(rwnd)**。
    * 拥塞控制：`慢开始`、`拥塞避免`、`快重传`、`快恢复`四个算法，以及**拥塞窗口(cwnd)**和**慢开始门限(ssthresh)**的变化。

* **形象记忆**:
    * **流量控制 vs 拥塞控制**:
        * **流量控制 (关心接收方)**: 我发太快，怕**你**一个人处理不过来。
        * **拥塞控制 (关心网络)**: 我发太快，怕把**路**给堵死了，影响**大家**。
    * **发送方的实际窗口**: 发送方能发多少，取决于“接收方还能装多少”和“网络还能承受多少”中的**较小者**。
        * `发送窗口 = min(rwnd, cwnd)`

* **【计算/分析模板】: TCP拥塞控制算法**
    > **场景**: 分析cwnd和ssthresh随网络事件的变化。

    1.  **初始状态**:
        * `cwnd = 1 MSS`
        * `ssthresh` 设置为一个较大值 (如65535 B)。
        * 进入**慢开始**阶段。

    2.  **慢开始阶段 (cwnd < ssthresh)**:
        * **规则**: 每收到一个ACK，`cwnd++`。效果是**每个RTT，cwnd翻倍** (指数增长)。
        * **目的**: 快速试探网络带宽。

    3.  **拥塞避免阶段 (cwnd >= ssthresh)**:
        * **规则**: 每经过一个RTT，`cwnd += 1 MSS` (线性增长)。
        * **目的**: 带宽已接近饱和，小心地增加发送速率。

    4.  **遇到网络拥塞事件**:
        * **事件1: 超时 (Timeout)** - **严重拥塞**
            * **动作**:
                * `ssthresh = cwnd / 2`
                * `cwnd = 1 MSS`
                * **返回慢开始阶段**。
            * **记忆**: “**一朝回到解放前**”。
        * **事件2: 收到3个冗余ACK** - **轻微拥塞**
            * **动作 (快重传与快恢复)**:
                * `ssthresh = cwnd / 2`
                * `cwnd = ssthresh` (或 `ssthresh+3`)
                * **直接进入拥塞避免阶段**。
            * **记忆**: “**直接腰斩，线性增长**”。

---

第五章的内容，TCP是重中之重。**三次握手、四次挥手**的图一定要会画，`seq`和`ack`的变化要了然于心。**拥塞控制**的四个算法以及`cwnd`和`ssthresh`的变化曲线图是分析大题的关键，必须熟练掌握。把这些核心拿下，传输层就不在话下！
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
